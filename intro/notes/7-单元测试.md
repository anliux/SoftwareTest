# 单元测试


### 目录
<!-- GFM-TOC -->
* [1 单元测试](#1-单元测试)
  * [单元测试概述](#单元测试概述)
  * [单元测试的目的和方法](#单元测试的目的和方法)
  * [单元测试的内容](#单元测试的内容)
  * [单元测试的实施步骤](#单元测试的实施步骤)
  * [单元测试自动化](#单元测试自动化)
* [2 代码扫描工具CA](#2-代码扫描工具ca)
  * [CA概述](#ca概述)
  * [CA的功能](#ca的功能)
* [3 CA的使用](#3-ca的使用)
  * [CA的代码分析流程](#ca的代码分析流程)
  * [CA的使用](#ca的使用)
<!-- GFM-TOC -->



# 1 单元测试

## 单元测试概述
- ### 定义
  - 单元测试是指对软件中的最小可测试单元或基本组成单元进行检查和验证。
  - 一般地，一个单元应具有明确的功能定义、性能定义，以及连接其他部分的接口定义等，且应可以清晰地与其他单元区分开来。

- ### 测试对象
  - 一个函数、一个类、一个窗口都可以看做是一个单元
  - 在此所指的单元主要是指函数。


## 单元测试的目的和方法
- ### 测试目的
  - 以分析单元的逻辑结构为基础，针对逻辑结构结合功能设计测试用例。

- ### 测试方法
  - 一般以白盒测试为主、结合黑盒测试的方法。允许多个测试单元的测试并行展开。
  

## 单元测试的内容
- ### 概述
  - 单元测试的主要内容包括静态测试和动态测试
    - 静态测试即查看程序源代码，执行代码扫描；
    - 动态测试则需要运行程序，完成测试，主要包括对模块接口、模块边界条件、模块独立路径和错误处理进行测试。

- ### 细节
  - 功能测试
  - 语句和分支覆盖率
  - 模块设计是否合理
  - 输入和输出接口测试
  - 内部数据流测试
  - 其它要特定要求的测试

- ### 策略
  - 逻辑覆盖
  - 循环覆盖
  - 同行评审
  - 桌前检查
  - 代码走查
  - 代码评审
  - 静态数据流分析
  
- ### 单元测试的主要技术手段
  - mock：对代码中某些不容易获取的对象创建虚拟对象来测试 
  - stub：桩函数是代替某些被调用了但是没有编写代码，一般再增量迭代自底向上的过程中不用编写。再自顶向下的过程中需要编写 
  - 驱动函数：调用被测函数，给被测函数传参  
  - 注：GUI测试是系统测试手段。 
  
  
## 单元测试的实施步骤
- ### 步骤概述
  - 理解需求和设计； 
  - 概览源代码；(粗略地)
  - 走读代码；(认真地)
  - 设计测试用例； 
  - 搭建测试环境；
  - 执行测试用例，
    - 注意：此时可能需要设计开发驱动模块或桩模块； 
  - 重复进行设计测试用例和加载测试；
  - 分析判断，给出结论。

- ### 理解需求和设计
  - ![理解需求和设计](https://raw.githubusercontent.com/anliux/SoftwareTest/master/intro/images/07-%E7%90%86%E8%A7%A3%E9%9C%80%E6%B1%82%E5%92%8C%E8%AE%BE%E8%AE%A1.png)

- ### 搭建测试环境
  - ![搭建测试环境](https://raw.githubusercontent.com/anliux/SoftwareTest/master/intro/images/07-%E6%90%AD%E5%BB%BA%E6%B5%8B%E8%AF%95%E7%8E%AF%E5%A2%83.png)
  - 驱动模块和桩模块：当某个模块开发完成，而其他模块还没时，为了完整地运行已开发完成模块而进行的补充。
  - 驱动模块：模拟包含主函数的模块的功能。
  - 桩模块：模拟除了某模块和包含主函数的模块之外，使得程序顺利运行编译的后续模块。

## 单元测试自动化
- 按照预定的规范自动扫描对象，大大降低单元测试第一步人工检查的复杂性，提高代码的规范性

<!--GFM-TOC -->
* ### [返回目录](#目录)
<!--GFM-TOC -->



# 2 代码扫描工具CA

## CA概述
- ### 概述
  - 代码扫描工具 Code Analyzer（简称 CA）
  - 通过分析或检查源程序的语法、结构、过程以及接口来检查程序的正确性和规范性，找出代码中隐藏的错误和缺陷，提高代码质量。
  - CA 检查源代码的过程不需要实际执行程序，是一种自动静态检查的软件工具。

- ### CA的界面
  - ![CA的界面](https://raw.githubusercontent.com/anliux/SoftwareTest/master/intro/images/07-CA%E7%95%8C%E9%9D%A2.png)

- ### CA的架构 
  - ![CA的架构](https://raw.githubusercontent.com/anliux/SoftwareTest/master/intro/images/07-CA%E6%9E%B6%E6%9E%84.png)

- ### CA的特点
  - 多系统、多语言、跨平台支持
  - 无需测试用例的测试
  - 基于编译的代码分析
  - 集成与扩展性
  - 代码级测试覆盖
  - 多样化分析报告


## CA的功能
- ### 支持规则列表
  - 词法规则：CA支持英语的单词表，变量命名的定义来自于词表检查
  - 语法规则：CA通过标准化的语法模板来处理语义规则
  - 语义规则：CA通过调用标准化的处理程序来分析定义的规则
    - 支持用户开发自己的规则包，然后通过配置文件以插件的形式配置到CA中。
  
- ### 发现不符合编码规范的代码
  - 在扫描源代码时对安全规范子集中定义的规则进行逐条检查；
  - 如果发现有不符合项则报告在问题列表中，用户可通过行号、列号精确定位问题。

- ### 自动监控版本服务器，触发代码扫描及检测分析
  - CA可以通过以下方式来实现修改配置管理的提交脚本，潜入扫描触发程序。
  - 当用户check in程序的时候，脚本触发了CA，来进行代码扫描，并且提交扫描结果
 
- ### 支持云服务实现，支持跨internet实现源代码安全扫描“云服务”
  - CA可支持私有云服务的版本：通过本地化来扫描程序，生成xml，上传到云服务，再进行扫描处理，在云端保存扫描结果，并且提供浏览器访问服务。
 
- ### 支持主流IDE环境，开发人员桌面上即可进行扫描
  - CA支持通过命令行方式嵌入IDE的方式，可以通过配置IDE环境来调用命令行工作；
  - 也支持通过提供客户端的方式来工作，用户可以通过操作客户端来扫描制定的代码，甚至整个项目。

<!--GFM-TOC -->
* ### [返回目录](#目录)
<!--GFM-TOC -->



# 3 CA的使用

## CA的代码分析流程
- ### 具体流程
  - 代码预处理；
  - 对代码进行语法分析；
  - 生成代码执行树；
  - 对代码进行语义分析；
  - 生成分析报告。

- ### 图示
  - ![CA代码分析流程图示](https://raw.githubusercontent.com/anliux/SoftwareTest/master/intro/images/07-CA%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E6%B5%81%E7%A8%8B%E5%9B%BE%E7%A4%BA.png)


## CA的使用
- ### 使用概述
  - 非常简单，只需要导入源代码，设置好规则包，就可以启动执行代码分析；
  - 执行完毕后，产生执行日志，对源代码的分析结果将显示在错误日志中，提供查看。

- ### 使用图示
  - ![CA-导入源代码](https://raw.githubusercontent.com/anliux/SoftwareTest/master/intro/images/07-CA-%E5%AF%BC%E5%85%A5%E6%BA%90%E4%BB%A3%E7%A0%81.png)
  - ![CA-执行代码分析](https://raw.githubusercontent.com/anliux/SoftwareTest/master/intro/images/07-CA-%20%E6%89%A7%E8%A1%8C%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90.png)
  - ![CA-生成代码日志](https://raw.githubusercontent.com/anliux/SoftwareTest/master/intro/images/07-CA-%E4%BA%A7%E7%94%9F%E6%89%A7%E8%A1%8C%E6%97%A5%E5%BF%97.png)

<!--GFM-TOC -->
* ### [返回目录](#目录)
<!--GFM-TOC -->



### END
