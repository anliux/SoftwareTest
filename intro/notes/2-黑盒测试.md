# 黑盒测试


### 目录
<!-- GFM-TOC -->
* [1 黑盒测试概述](#1-黑盒测试概述)
  * [黑盒测试的基本原理](#黑盒测试的基本原理)
  * [黑盒测试的优缺点](#黑盒测试的优缺点)
  * [测试方法的评价标准](#测试方法的评价标准)
  * [黑盒测试用例设计方法](#黑盒测试用例设计方法)
* [2 边界值测试方法](#2-边界值测试方法)
  * [要解决的问题](#要解决的问题)
  * [面向输入域的边界值测试](#面向输入域的边界值测试)
  * [面向输出域的边界值测试](#面向输出域的边界值测试)
* [3 等价类测试](#3-等价类测试)
  * [面向输入域的等价类测试](#面向输入域的等价类测试)
  * [面向输出域的等价类测试](#面向输出域的等价类测试)
  * [注意](#注意)
* [4 基于场景的测试](#4-基于场景的测试)
  * [辨析](#辨析)
  * [产生原因](#产生原因)
  * [基于场景的测试基本原理](#基于场景的测试基本原理)
  * [场景法面临的问题](#场景法面临的问题)
  * [基于场景的测试用例设计一般步骤](#基于场景的测试用例设计一般步骤)
<!-- GFM-TOC -->



# 1 黑盒测试概述

## 黑盒测试的基本原理
- ### 原理：
  - 只知道系统输入和预期输出，不需要了解程序内部结构和内部特性的测试方法就称为黑盒测试。

- ### 原理图解
  ![黑盒测试的基本原理](https://raw.githubusercontent.com/anliux/SoftwareTest/master/intro/images/02-%E9%BB%91%E7%9B%92%E6%B5%8B%E8%AF%95%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86.png)


## 黑盒测试的优缺点
- ### 优势
  - 方法简单有效
  - 可以整体测试系统的行为
  - 开发与测试可以并行
  - 对测试人员技术要求相对较低

- ### 劣势
  - 入门门槛低


## 测试方法的评价标准
- ### 评价标准
  - 在最短时间内，以最少的人力，有利于发现最多的，以及最严重的缺陷。
  - 精确的：测试针对性强
  - 完备的：测试覆盖全面，无漏洞
  - 无冗余：测试用例所关联的风险有所区别
  - 简单的：测试方法简单易行
  - 易于调试：缺陷定位难度

- ### 原则
  - 一个中心，两个坚持
  - 以用户需求为中心；
  - 坚持高效的测试用例设计；
  - 坚持缺陷的快速处理。

- ### 测试方法的评价
  - 测试用例的覆盖度：高
  - 测试用例的数量：少
  - 测试用例的冗余度：低
  - 测试方法的复杂度：低


## 黑盒测试用例设计方法
- 基于用户需求的测试；

- #### 边界值分析方法；
  - 围绕被测系统边界展开测试用例设计的问题。

- #### 等价类划分方法；
  - 基于等价划分的思想，使用有限的测试用例达到穷尽测试的目标

- 错误推测方法；

- 因果图方法；

- 判定表驱动分析方法；

- 正交实验法；

- #### 场景法。
  - 何面向业务流程进行测试设计的问题

<!--GFM-TOC -->
* ### [返回目录](#目录)
<!--GFM-TOC -->



# 2 边界值测试方法

## 要解决的问题
- ### 边界在哪里?
  - 边界点就是可能导致被测系统内部处理机制发生变化的点
  - 需求中有利于识别边界点的文字:
    - 位置，尺寸，数量，长度，速度，高度，距离，质量，时间…
  - 可能的边界点:
    - 第一个/最后一个，最小/最大，最少/最多，最短/最长，最快/最慢，最高/最低，最近/最远，最轻/最重，最早/最晚…

- ### 如何定义边界的邻域?
  - 单边界值

- ### 如何选择测试数据？

- ### 如何设计测试用例？


## 面向输入域的边界值测试
- 找到系统输入条件，基于独立性原则，确定每个输入条件的边界点。 
- 围绕每个边界点，确定边界附近的邻域范围，并挑选测试数据。
  - 若以 a 为边界值，则通常选择 a-δ, a, a+δ为测试数据，一般取δ = 1。 
- 根据选定的测试数据，基于单边界原则，设计测试用例。
- 根据系统需求，补充边界测试用例。


## 面向输出域的边界值测试
- 若被测对象的输入域与输出域很不相似，则可能需要面向输出域补充进行边界值测试，

- ### 一般步骤如下：
  - 找到系统输出，确定输出的边界点。
  - 围绕每个边界点，确定边界附近的邻域范围，并挑选测试数据。
    - 若以 a 为边界值，通常选择 a-δ, a, a+δ为测试数据，一般取δ = 1。 
  - 根据选定的输出域测试数据，确定输入域对应的输入条件及数据，并设计测试用例。

<!--GFM-TOC -->
* ### [返回目录](#目录)
<!--GFM-TOC -->



# 3 等价类测试

## 面向输入域的等价类测试
- ### 基本原理
  - 面向输入域等价类测试的基本原理：采用分而治之的思想，将输入域进行等价划分；
  - 其中，等价划分满足 3 个约束，然后在每个等价类中仅抽取一个数据，从而将不可能的穷尽测试转化为有限个数据构成的测试用例的集合。
  
- ### 3个约束：
  - 分而不交：
    - 划分出的任意两个等价类之间不存在交集；
    - 测试无冗余。
  - 合而不变：
    - 所有等价类的并集仍然是原始的输入域；
    - 测试无漏洞。
  - 类内等价：
    - 任意一个等价类中，所有数据相互“等价”；
    - 以一代全。

- ### 等价类的划分
  - 有效等价类
    - 输入域中一组有意义的数据的集合
    - 有效等价类被用于检验系统指定功能和性能能否正确实现
  - 无效等价类
    - 输入域中一组无意义的数据的集合
    - 无效等价类被用于检验系统的容错性

- ### 设计测试用例
  - 弱覆盖
    - 测试用例应覆盖所有的有效等价类
  - 强覆盖
    - 测试用例应覆盖所有的有效等价类的组合
    - 例如：当有效等价类有多个范围时，弱覆盖无法覆盖所有情况。

- ### 等价划分的陷阱1
  - 确定输入条件时，可能会改变原始输入域
    - 例如：以独立性原则，将日期设为1-31日时，可能超过原范围。
    - 这样得到的测试用例仍正确，没有漏洞，但有冗余。
  - 两种划分等价类的方式:
    - 基于系统实现的等价划分：
      - 从程序员实现系统的角度出发，多关注接口。
    - 基于用户需求的等价划分：
      - 从功能和业务处理机制角度出发，多关注隐含系统内部处理流程。
  - #### 总结：
    - 尽量从用户角度分析需求，避免改变原始输入域。

- ### 等价划分的陷阱2
  - 对有效域和无效域可以用相同方式进行等价类测试吗？
    - 有效等价类
      - 输入域中一组有意义的数据的集合
      - 有效等价类被用于检验系统指定功能和性能能否正确实现
    - 无效等价类
      - 输入域中一组无意义的数据的集合
      - 无效等价类被用于检验系统的容错性
      - 可能出现无法定位缺陷的问题
  - #### 总结：
    - 在有效域：使用组合机制
    - 在无效域：使用单缺陷机制。

- ### 等价划分的陷阱3
  - 如何选择合适的覆盖指标 
    - 划分出最多有效等价类的那个输入条件决定弱覆盖指标的最少测试用例数。
    - 强覆盖指标下，测试用例的数量是每个输入条件所拥有的有效等价类数量的乘积。
  - 测试用例规模：
    - 弱 <<< 强，可在项目紧急情况下适当选择弱覆盖。
  - #### 总结：
    - 一般采用强覆盖；
    - 进度紧张时可选弱覆盖。

- ### 等价划分的陷阱4
  - 等价类测试真的没有漏洞，没有冗余吗？
    - 等价划分不彻底：将导致测试的漏洞。
      - 例如：日期设计中，31日后一天的处理，其他月份是本年下个月，而12月的31日会跨年，应分开设置。
    - 输入条件直接存在关联时：引入独立性原则将造成测试冗余。
  - 总结：
    - 务必确保数据的等价性，避免漏洞；
    - 等价划分兼顾输入的关联性，避免冗余。

- ### 面向输入的等价类测试的基本步骤如下：
  - #### 在有效域内：
    - 基于独立性原则，将数据划分到不同的有效等价类中，然后选择弱覆盖标准，或强覆盖标准设计测试用例。
    - 确保每个测试用例覆盖的均为有效等价类。
  - #### 在无效域内：
    - 将数据划分到不同的无效等价类中，然后基于单缺陷原则设计测试用例。
    - 不应该出现多个无效等价类组合成测试用例的情况。
  - 注意：
    - 受到输入条件之间的关联性影响，以及等价划分的正确性影响，等价类测试得到的测试用例不一定能保证无漏洞、无冗余。


## 面向输出域的等价类测试
- 若被测对象的输入域与输出域很不相似，则可能需要面向输出域补充进行等价类测试。

- ### 一般步骤如下：
  - 在输出域内，划分等价类；
  - 在每个等价类中随意抽取一个数据；
  - 针对选择的输出测试数据，确定输入条件及数据，设计测试用例。


## 注意：  
- 输入域：需要严格区分有效域和无效域。
- 输出域：不存在无效输出域的概念。

<!--GFM-TOC -->
* ### [返回目录](#目录)
<!--GFM-TOC -->



# 4 基于场景的测试

## 辨析
- ### 边界值测试和等价类测试：
  - 主要解决数据穷尽测试的问题；
  - 面向数据的测试，忽略了对流程的考虑。
  
- ### 面对业务流程的测试：
  - 可基于事件流的思想采用场景法进行测试设计。


## 产生原因
- 越来越多的软件系统采用事件触发来控制流程
- 事件触发时的情景形成场景
- 同一事件不同的触发顺序和处理结果形成事件流


## 基于场景的测试基本原理
- ### 以事件流为核心
  - 包括：基本流和备选流

- ### 场景：
  - 从系统某个初始态开始，到达某个结束状态为止所经过的路径就构成一个用例场景。

- ### 图解
  ![基于场景测试的基本原理](https://raw.githubusercontent.com/anliux/SoftwareTest/master/intro/images/02-%E5%9F%BA%E4%BA%8E%E5%9C%BA%E6%99%AF%E6%B5%8B%E8%AF%95%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86.png)


## 场景法面临的问题
- ### 如何定义基本流和备选流? 
  - 基本流：中轴线，是从初始态到终止态的一个最主要的业务流程。
    - 测试中，至少需要确保系统基本流的执行是完全正确的。
    - 对系统从某个初始态到某个终止态的事件流而言，基本流是唯一的。
  - 基本流选择：
    - 应选择容易出错的，或者出错后导致损失严重的高风险事件流作为基本流。
  - 高风险事件流：
    - 操作频率高
    - 涉及业务规则复杂
    - 涉及重要功能
    - 涉及用户类型广泛
    - 涉及用户数量大
    - 涉及交互复杂
  - 备选流：仅为整个执行过程中的一个片段。
    - 备选流可以有多个；
      - 基本流的判定节点越多，产生的备选流越多。
    - 节点选择多样：
      - 起始节点从基本流的某个判定节点开始；  
      - 起始节点从其他备选流的某个判定节点开始；
      - 终止节点是基本流上的某个状态；
      - 终止节点是其他的系统终止状态；
      - 备选流上的每个节点执行后可以继续往下执行(判定结构)，也可以返回基本流上的某个节点继续执行(循环结构)。
  - 基本流与备选流的区别
    ![基本流与备选流的区别](https://raw.githubusercontent.com/anliux/SoftwareTest/master/intro/images/02-%E5%9F%BA%E6%9C%AC%E6%B5%81%E4%B8%8E%E5%A4%87%E9%80%89%E6%B5%81%E7%9A%84%E5%8C%BA%E5%88%AB.png)

- ### 如何定义场景？
  - 场景定义：
    - 可以看做是基本流和备选流的有序集合。
    - 一个场景中至少应包含一条基本流。
  - 场景选择：场景流+若干备选流。
    - 场景1：基本流
    - 场景2：基本流+备选流1
    - 场景3：基本流+备选流1+备选流2
    - 场景4：基本流+备选流3
    - 场景5：基本流+备选流4
    - 场景6：基本流+备选流3+备选流1
    - 场景7：基本流+备选流3+备选流1+备选流2
    - 场景8：基本流+备选流3+备选流4

- ### 如何设计测试用例？
  - 找到输入条件
  - 判断是否有效条件
  - 判断是否触发条件
  - 需要取哪些测试数据
  - 得到系统预期输出


## 基于场景的测试用例设计一般步骤
- ### 步骤：
  - 基于风险确定基本事件流和备选事件流。
  - 以基本事件流和备选事件流构建场景。
  - 从场景设计测试用例
    - 即找到输入条件，判断是否有效条件、是否触发条件、需要取哪些测试数据，并得到系统预期输出。

- ### 注意：
  - 从原理图可以看出，如果备选事件流过多，则将导致要测试的场景数量会变得十分庞大；
  - 因此，备选事件流的选择需要结合等价划分的结果，在某个节点选择备选事件流时，凡是不符合正常业务流程的，均可统一划归为异常业务流程，作为一个备选事件流。

<!--GFM-TOC -->
* ### [返回目录](#目录)
<!--GFM-TOC -->



### END
