# 白盒测试-1


### 目录
<!-- GFM-TOC -->
* [1 白盒测试概述](#1-白盒测试概述)
  * [白盒测试的基本原理](#白盒测试的基本原理)
  * [关注的对象](#关注的对象)
  * [白盒测试的优缺点](#白盒测试的优缺点)
  * [白盒测试的经济学问题](#白盒测试的经济学问题)
  * [白盒测试用例设计方法](#白盒测试用例设计方法)
* [2 控制流分析技术](#2-控制流分析技术)
  * [控制流分析要解决的问题](#控制流分析要解决的问题)
  * [控制流分析的内容](#控制流分析的内容)
* [3 对判定节点展开测试用例设计](#3-对判定节点展开测试用例设计)
  * [逻辑覆盖：对判定的测试](#逻辑覆盖：对判定的测试)
  * [要解决的问题](#要解决的问题)
  * [1-语句覆盖](#1-语句覆盖)
  * [2-判定覆盖](#2-判定覆盖)
  * [3-条件覆盖](#3-条件覆盖)
  * [4-判定/条件覆盖](#4-判定/条件覆盖)
  * [5-条件组合覆盖](#5-条件组合覆盖)
  * [6-修正的判定/条件覆盖](#6-修正的判定/条件覆盖)
  * [对判定的测试小结](#对判定的测试小结)
  * [图解总结](#图解总结)
  * [注意点小结](#注意点小结)
* [4 静态白盒测试](#4-静态白盒测试)
  * [静态白盒测试介绍](#静态白盒测试介绍)
  * [代码检查](#代码检查)
  * [静态结构分析](#静态结构分析)
<!-- GFM-TOC -->



# 1 白盒测试概述

## 白盒测试的基本原理
- ### 原理
  - 白盒测试就是基于程序的源代码，已知产品的内部工作过程，主要对程序内部结构展开测试，关注程序实现细节的测试方法。

- ### 原理图解
  ![白盒测试的基本原理](https://raw.githubusercontent.com/anliux/SoftwareTest/master/intro/images/03-%E7%99%BD%E7%9B%92%E6%B5%8B%E8%AF%95%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86.png)


## 关注的对象
- ### 源代码
  - 措施：阅读源代码，检验代码的规范性，并对照函数功能查找代码的逻辑缺陷、内存管理缺陷、数据定义和使用缺陷等

- ### 程序结构
  - 措施：使用与程序设计相关的图表，找到程序设计的缺陷，或评价程序的执行效率


## 白盒测试的优缺点
- ### 优势
  - 针对性强，便于快速定位缺陷
  - 在函数级别开始测试工作，缺陷修复的成本低
  - 有助于了解测试的覆盖程度
  - 有助于代码优化和缺陷预防

- ### 不足
  - 对测试人员要求高
    - 测试人员需要具备一定的编程经验
    - 白盒测试工程师需要具备广博的知识面
  - 成本高
    - 白盒测试准备时间较长


## 白盒测试的经济学问题
- 软件测试是不完备的
- 软件测试是有风险的
- 测试设计应达到的目标
  - 提高效率
  - 降低风险


## 白盒测试用例设计方法
- 语句覆盖、判定覆盖、条件覆盖、判定/条件覆盖、条件组合覆盖和路径覆盖。

<!--GFM-TOC -->
* ### [返回目录](#目录)
<!--GFM-TOC -->



# 2 控制流分析技术

## 控制流分析要解决的问题
- 什么因素导致程序结构变得复杂？-- 判定节点
- 如何衡量程序结构的复杂程度？ -- 判定节点
- 控制程序执行流程发生变化的主要因素是什么？
- 如何测试这些因素，并确保测试的效率？


## 控制流分析的内容
- ### 关注判定节点固有的复杂性
  - 焦点：判定表达式
  - 方法：逻辑覆盖测试

- ### 关注判定结构与循环结构对执行路径产生的影响
  - 焦点：路径
  - 方法：独立路径测试
  
- ### 关注循环结构本身的复杂性
  - 焦点：循环体
  - 方法：基于数据的静态分析

<!--GFM-TOC -->
* ### [返回目录](#目录)
<!--GFM-TOC -->



# 3 对判定节点展开测试用例设计

## 逻辑覆盖：对判定的测试
- 关注点：判定表达式本身的复杂度
- 原理：通过对程序逻辑结构的遍历，来实现测试对程序的覆盖
- 原则：对程序代码中所有的逻辑值，都需要测试真值（True）和假值（False）的情况


## 要解决的问题
- 对于选定的覆盖指标，如何控制测试用例规模，提高测试用例典型性，避免测试漏洞？
- 如何选择合适的覆盖指标？


## 1-语句覆盖
- ### 含义
  - 语句覆盖(Statement coverage)
  - 设计测试用例时应保证程序中每一条可执行语句至少应执行一次

- ### 图示
  ![语句覆盖示例](https://raw.githubusercontent.com/anliux/SoftwareTest/master/intro/images/03-%E8%AF%AD%E5%8F%A5%E8%A6%86%E7%9B%96%E7%A4%BA%E4%BE%8B.png)
 
- ### 特点
  - 控制流图中的点覆盖

- ### 不足
  - 语句覆盖是最弱的覆盖准则
  - 关注语句，而非关注判定节点
  - 对隐式分支无效
 
- ### 对策
  - 优选测试数据
  - 更强的覆盖准则：判定覆盖


## 2-判定覆盖
- ### 含义
  - 判定覆盖(Branch coverage)
  - 设计测试用例时应保证程序中每个判定节点取得每种可能的结果至少一次。

- ### 图示
  ![判定覆盖示例](https://raw.githubusercontent.com/anliux/SoftwareTest/master/intro/images/03-%E5%88%A4%E5%AE%9A%E8%A6%86%E7%9B%96%E7%A4%BA%E4%BE%8B.png)

- ### 特点
  - 控制流图中的边覆盖

- ### 不足
  - 仅关心表达式的整体取值，不能覆盖到每个子条件的所有取值情况。
    - 例如：当判定节点包含的是复合判定表达式时，即由多个简单判定条件连接而成时。

- ### 对策
  - 更严格的覆盖检查


## 3-条件覆盖
- ### 含义
  - 条件覆盖(Condition coverage)
  - 设计测试用例时应保证程序中每个复合判定表达式中，每个简单判定条件的取真和取假情况至少执行一次

- ### 图示
  ![条件覆盖示例](https://raw.githubusercontent.com/anliux/SoftwareTest/master/intro/images/03-%E6%9D%A1%E4%BB%B6%E8%A6%86%E7%9B%96%E7%A4%BA%E4%BE%8B.png)

- ### 不足
  - 不一定满足判定覆盖。
  - 即判定节点局部全覆盖不等于判定节点整体全覆盖。


## 4-判定/条件覆盖
- ### 含义
  - 判定/条件覆盖(Branch/Condition coverage)
  - 设计测试用例时应满足判定节点的取真、取假分支至少执行一次；
  - 且每个简单判定条件的取真和取假情况也至少执行一次

- ### 图示
  ![判定/条件覆盖示例](https://github.com/anliux/SoftwareTest/blob/master/intro/images/03-%E5%88%A4%E5%AE%9A%E6%9D%A1%E4%BB%B6%E8%A6%86%E7%9B%96%E7%A4%BA%E4%BE%8B.png)

- ### 特点
  - 判定覆盖+条件覆盖

- ### 不足
  - 测试用例设计复杂


## 5-条件组合覆盖
- ### 含义
  - 条件/组合覆盖(Condition combination coverage)
  - 设计测试用例时应满足每个判定节点中，所有简单判定条件的所有可能的取值组合情况至少执行一次
  - 以测试条件的冗余，换取方法的简单性。
  - 本质：真值表

- ### 图示
  ![条件组合覆盖示例](https://raw.githubusercontent.com/anliux/SoftwareTest/master/intro/images/03-%E6%9D%A1%E4%BB%B6%E7%BB%84%E5%90%88%E8%A6%86%E7%9B%96%E7%A4%BA%E4%BE%8B.png)

- ### 特点
  - 方法简单

- ### 不足
  - 测试用例太多，冗余严重


## 6-修正的判定/条件覆盖
- ### 含义 
  - 修正的判定/条件覆盖(Modified Condition/Decision coverage)
  - 在满足判定/条件覆盖的基础上，每个简单判定条件都应__独立地影响__到整个判定表达式的取值。

- ### 真值表图示
  ![修正的判定/条件覆盖示例](https://raw.githubusercontent.com/anliux/SoftwareTest/master/intro/images/03-%E4%BF%AE%E6%AD%A3%E7%9A%84%E5%88%A4%E5%AE%9A%E6%9D%A1%E4%BB%B6%E8%A6%86%E7%9B%96%E7%A4%BA%E4%BE%8B.png)

- ### 特点
  - 判定覆盖+条件覆盖+独立影响性
  - 实质：利用简单判定条件的独立影响性来消除测试用例的冗余。

- ### 测试用例设计的一般步骤
  - 列出所有简单判定条件；
  - 构建真值表；
  - 对每个简单判定条件，找到能对整个判定结果产生独立影响的测试用例集合（简称独立影响对）
    - 即在真值表中依次固定其他简单判定条件，找到该条件的独立影响对；
  - 抽取能体现所有简单判定条件独立影响性的最少独立影响对。

- ### 优势
  - 综合具备条件组合覆盖的优点，有效控制了测试用例数量，消除了测试冗余。
  
- ### 不足
  - 测试用例设计较为困难。
  - 无法处理耦合的表达式。


## 对判定的测试小结
- ### 考察源代码中的判定表达式进行测试
 
- ### 常见的覆盖指标
  - 语句覆盖(语句覆盖弱)
  - 判定覆盖(覆盖不全面)
  - 条件覆盖(覆盖不全面)
  - 判定/条件覆盖(设计难度大)
  - 条件组合覆盖(测试用例数量太多)
  - 修正的判定/条件覆盖
  - 注：前三个使用最广泛。判定覆盖最多。


## 图解总结
![不同覆盖指标的比较](https://raw.githubusercontent.com/anliux/SoftwareTest/master/intro/images/03-%E4%B8%8D%E5%90%8C%E8%A6%86%E7%9B%96%E6%8C%87%E6%A0%87%E7%9A%84%E6%AF%94%E8%BE%83.png)


## 注意点小结
- ### 请注意：
  - 上述指标在实际使用中并不需要全部采用，通常使用较多的是判定覆盖指标。

- ### 其他
  - 白盒测试用例的设计并不等同于调试程序的过程中，通过简单输入一些预先设想的数据，看看程序能够返回正确结果。
  - 从代码的层面来说，测试用例设计的更多目的是为了支持自动化单元测试。
  - 以及我们通常所谈的白盒测试方法也同样适用于在功能测试中使用，这一点，在后续的路径测试中会进一步体会到。

<!--GFM-TOC -->
* ### [返回目录](#目录)
<!--GFM-TOC -->



# 4 静态白盒测试

## 静态白盒测试介绍
- ### 定义
  - 不需要实际运行被测软件，而是直接对软件形式和结构进行分析。
  
- ### 分类
  - 静态白盒测试主要包括代码检查、静态结构分析、代码质量度量等。


## 代码检查
- ### 概述
  - 主要是通过同行评审来发现缺陷；
  - 主要以评审会议为形式，通过多人对软件交付物进行检查，从而发现缺陷或获得改进优化的机会。
  - 同行评审方法遵循的评审流程大同小异，但随着这些方法的正式程度不同，适用的对象、评审形式等方面也存在一定的差异。
  - 同行评审往往需要大量投入时间和人力资源。

- ### 对比
  - 动态测试的局限性
    - 开发早期无法提供可运行对象，导致无法执行测试
    - 特定类型的缺陷，通过测试无法发现
  - 同行评审的优势
    - 促使参与者在有监督压力下工作，提高责任心
    - 有助于在开发早期发现需求和设计中的缺陷
    - 有助于帮助程序员发现不足，提高工作质量

- ### 同行评审
  - 同行评审的核心：缺陷预防
  - 目的：发现缺陷，改进开发过程

- ### 同行评审的方法分类
  - 审查(Inspection)
  - 团队评审(Team Review)
  - 走查(Walk Through)
  - 结对编程(Pair Programming)
  - 同行桌查(Peer Desk Check)
  - 轮查(Pass Around)
  - 特别检查(Ad hoc Review)
  - 结对编程、同行桌查、轮查、特别检查：
    - 较随意，目的是发现缺陷，过程简洁，1-2人，快速审查。
  - 审查、团队评审、走查：
    - 更正规，目的是发现缺陷，改进开发质量，被评审的对象更关键，流程更复杂。

- ### 同行评审的流程
  ![同行评审的流程](https://raw.githubusercontent.com/anliux/SoftwareTest/master/intro/images/03-%E5%90%8C%E8%A1%8C%E8%AF%84%E5%AE%A1%E7%9A%84%E6%B5%81%E7%A8%8B.png)

- ### 评审结果
  - 正常：
    - 评审专家做好了评审准备，评审会议顺利进行，达到了预期目的，达成明确的评审结论，不需要再次评审。
  - 延期：
    - 30%以上的评审专家并未做好评审准备，会议无法正常进行，需要重新安排评审日程。
  - 取消：
    - 初审阶段就发现工作产品中存在太多问题，需要作者进行修复，然后再进行第二次同行评审。

- ### 评审主要参与人
  - 主持人：组织评审会议
  - 讲解员：讲解被评审的工作产品
  - 作者：被评审工作产品的提供者
  - 评审员：评审工作产品
  - 记录员：记录缺陷和决议

- ### 评审流程分析
  - 同行评审的有效性取决于评审流程的规范性、评审专家对工作产品和评审流程的熟悉程度，以及所有参与人员的态度等多方面因素。
  - 在缺乏规范、缺乏有效组织、缺乏责任心和检查工具的情况下，同行评审只是在浪费时间。
  - 所以，不妨从结对编程开始，从遵循行 业已有的规范开始，尝试有监督的开发。


## 静态结构分析
- ### 概述
  - 静态结构分析就是通过分析程序相关的图表，从而快速了解程序设计和结构，更好地理解源代码，找到程序设计的缺陷和代码优化的方向。

- ### 具体
  - 通过引入多种形式的图表（如函数调用关系图、模块控制流图等）
  - 帮助我们快速了解程序设计和结构，更好地理解源代码，有利于找到程序设计的缺陷和代码优化的方向。

- ### 看函数调用关系图 
  - 从函数调用图看程序结构包括如下方面。 
  - （1）看函数调用层次。
    - 层次太深，将增大集成测试的负担，造成风险。
    - 对栈造成压力，容易导致溢出。
    - 控制单个函数的复杂度。
    - 要在函数调用层次与单个函数复杂度之间达到平衡。
  - （2）看函数调用关系，标识高风险节点。
    - 高风险节点：调用层次深；缺陷隐藏深。
    - 调用层次深的节点，根节点，出度大的节点，入度大的节点，都是高风险节点。
      - 入度越大，缺陷传播速度越快
      - 出度越大，对缺陷的敏感度越高
  - （3）看递归调用。
    - 递归调用往往对内存消耗较大。
    - 如果存在递归调用，尽量改为循环。
  - （4）看孤立节点。
    - 孤立的函数意味着不执行的场景或路径，代表编码或设计的不合理；
    - 尽量避免孤立节点

- ### 看控制流图 
  - 控制流图
    - 由节点和边组成的有向图
    - 节点表示一条或多条语句
    - 边表示节点之间的控制走向，即语句的执行
  - 控制流图的作用
    - 直观反映函数的内部逻辑结构
    - 展示程序中明显的缺陷
    - 揭示程序是否隐含缺陷
  - 从控制流图看程序结构包括如下方面：
  - （1）看孤立节点。
    - 从控制流图看是否存在孤立节点。
  - （2）看出口节点。
    - 理想的是单入口单出口的。
    - 多出口带来高复杂度，应尽量避免多出口。
  - （3）看环复杂度。
    - 环复杂度应控制在 10 以内。 
    - 导致环复杂度过高的主要原因：
      - 出口节点数量太多；
      - 判定节点数目太多；
      - 未采用结构化的程序设计等。
  - （4）非结构化设计。
    - 非结构化的语句：强行跳入跳出，goto，break，continue等语句导致。
    - 弊端：
      - 由于存在强制跳入跳出，导致并非所有分支都执行到结束节点，而会出现执行到其他节点退出的情况。
      - 程序可读性差，增加测试难度和工作量，容易导致缺陷，测试中不易发现。
    - 应尽量避免非结构化设计。

- ### 如何改进结构设计不合理的函数？
  - （1）孤立节点：避免孤立节点；
  - （2）多出口：尽量避免多次使用 return 语句，尽量将有效性校验前置；
  - （3）环复杂度：应将完成单一功能的语句块改为函数调用的方式，降低单个函数复杂度；
  - （4）非结构化设计：尽量不使用强制跳转或强制结束语句，避免非结构化设计。

<!--GFM-TOC -->
* ### [返回目录](#目录)
<!--GFM-TOC -->



### END
